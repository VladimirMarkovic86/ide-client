(ns ide-client.working-area.file-system.controller
  (:require [htmlcss-lib.core :refer [gen div input menu menuitem
                                      textarea img video audio source a]]
            [js-lib.core :as md]
            [ajax-lib.core :refer [ajax get-response base-url]]
            [ajax-lib.http.request-header :as rh]
            [ajax-lib.http.mime-type :as mt]
            [ide-middle.request-urls :as irurls]
            [framework-lib.core :as frm]
            [language-lib.core :refer [get-label]]
            [clojure.string :as cstring]))

(def current-directory
     (atom ""))

(def remembered-value
     (atom nil))

(def cut-value
      (atom ""))

(def copy-value
      (atom ""))

(def display-as-text
     #{"txt"
       "html"
       "css"
       "js"
       "sh"
       "md"
       "clj"
       "cljs"})

(def display-as-image
     #{"jpeg"
       "jpg"
       "png"
       "gif"
       "bmp"})

(def display-as-video
     #{"mp4"
       "mkv"
       "webm"})

(def display-as-audio
     #{"mp3"
       "m4a"})

(defn empty-then-append
  "Empty content and append new one"
  [selector
   new-content]
  (md/remove-element-content
    selector)
  (md/append-element
    selector
    new-content))

(defn escape-space
  "Escape space sign"
  [path]
  (let [escaped-path (atom "")]
    (doseq [c-char path]
      (if (= c-char
             \space)
        (swap!
          escaped-path
          str
          "\\ ")
        (swap!
          escaped-path
          str
          c-char))
     )
    @escaped-path))

(defn form-absolute-path
  "Form absolute path for \"ls -al\" query"
  [current-path
   opened-directory]
  (let [final-path (atom "")]
    (when (= opened-directory
             ".")
      (swap!
        final-path
        str
        current-path))
    (when (= opened-directory
             "..")
      (let [directories (cstring/split
                          current-path
                          #"/")]
        (if (contains?
              #{0 2}
               (count directories))
          (swap!
            final-path
            str
            "/")
          (doseq [index (range 1 (dec
                                 (count directories))
                         )]
            (swap!
              final-path
              str
              "/"
              (get
                directories
                index))
           ))
       ))
    (when (not (or (= opened-directory
                      ".")
                   (= opened-directory
                      ".."))
           )
      (if (= current-path
             "/")
        (swap!
          final-path
          str
          "/"
          opened-directory)
        (swap!
          final-path
          str
          current-path
          "/"
          opened-directory))
     )
    @final-path))

(defn list-file-system-fn
  "Execute shell command \"ls -al\" on server"
  [{dir-name :dir-name
    success-fn :success-fn}]
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn success-fn
     :entity {:command (str
                         "ls -al "
                         (form-absolute-path
                           (escape-space
                             @current-directory)
                           (escape-space
                             dir-name))
                        )}
     :dir-name dir-name}))

(defn parse-doc-name
  "Parse document name from line in table of files generated by command \"ls -al\""
  [line]
  (let [separators-count (atom 0)
        previous-char (atom nil)
        doc-name (atom "")]
    (doseq [c-char line]
      (when (> @separators-count
               7)
        (swap!
          doc-name
          str
          c-char))
      (when (and (= c-char
                    \space)
                 (not= @previous-char
                       \space))
        (swap!
          separators-count
          inc))
      (reset!
        previous-char
        c-char))
    @doc-name))

(defn textarea-fn
  "Generate textarea HTML element"
  [& [content]]
  (gen
    (textarea
      (if-let [content content]
        content
        "")
      {:readonly true}))
 )

(defn image-fn
  "Generate image HTML element"
  [& [src]]
  (gen
    (img
      ""
      {:src (if-let [src src]
              src
              "")
       :style {:max-width "100%"
               :max-height "100%"}}))
 )

(defn video-fn
  "Generate image HTML element"
  [& [src]]
  (gen
    (video
      (source
        ""
        {:src (if-let [src src]
                src
                "")})
      {:width "100%"
       :height "100%"
       :controls true}))
 )

(defn audio-fn
  "Generate audio HTML element"
  [& [src]]
  (gen
    (audio
      (source
        ""
        {:src (if-let [src src]
                src
                "")})
      {:width "100%"
       :height "100%"
       :controls true}))
 )

(defn read-file-success
  "Display file if format is supported success"
  [xhr
   ajax-params]
  (md/remove-element-content
    "#display-file")
  (let [operation (get-in
                    ajax-params
                    [:entity
                     :operation])]
    (when (= operation
             "read")
      (let [response (get-response
                       xhr)
            textarea-obj (textarea-fn
                           response)]
        (md/append-element
          "#display-file"
          textarea-obj))
     )
    (when (= operation
             "image")
      (let [response (get-response
                       xhr)
            url-creator (aget
                          js/window
                          "URL")
            image-url (.createObjectURL
                        url-creator
                        response)
            image-obj (image-fn
                        image-url)]
        (md/append-element
          "#display-file"
          image-obj))
     ))
 )

(defn display-file-fn
  "Display file if format is supported request"
  [file-name]
  (let [file-path (str
                    @current-directory
                    "/" file-name)
        extension-start (cstring/last-index-of
                          file-name
                          ".")
        extension (.substr
                    file-name
                    (inc
                      extension-start)
                    (count
                      file-name))
        display-as-text? (contains?
                           display-as-text
                           extension)
        display-as-image? (contains?
                            display-as-image
                            extension)
        display-as-video? (contains?
                            display-as-video
                            extension)
        display-as-audio? (contains?
                            display-as-audio
                            extension)]
    (when display-as-text?
      (ajax
        {:url irurls/read-file-url
         :success-fn read-file-success
         :request-header-map {(rh/accept) (mt/text-plain)}
         :request-property-map {"responseType" (mt/text-plain)
                                "cljResponseType" (mt/text-plain)}
         :entity {:file-path file-path
                  :operation "read"}}))
    (when display-as-image?
      (ajax
        {:url irurls/read-file-url
         :success-fn read-file-success
         :request-header-map {(rh/accept) (str "image/" extension)}
         :request-property-map {"responseType" "blob"
                                "cljResponseType" "blob"}
         :entity {:file-path file-path
                  :operation "image"}})
     )
    (when display-as-video?
      (md/remove-element-content
        "#display-file")
      (let [video-url (str
                        @base-url
                        irurls/video-url
                        "?filepath="
                        file-path)
            video-obj (video-fn
                        video-url)]
        (md/append-element
          "#display-file"
          video-obj))
     )
    (when display-as-audio?
      (md/remove-element-content
        "#display-file")
      (let [audio-url (str
                        @base-url
                        irurls/video-url
                        "?filepath="
                        file-path)
            audio-obj (audio-fn
                        audio-url)]
        (md/append-element
          "#display-file"
          audio-obj))
     ))
 )

(defn remember-element-fn
  "Cut and copy clipboard"
  [_
   element]
  (reset!
    remembered-value
    (aget
      element
      "text"))
 )

(defn a-fn
  "Generate a HTML element"
  [content
   a-evts]
  (gen
    (a
      content
      nil
      a-evts))
 )

(defn prepare-file-system-fn-success2
  "Generate and render file system"
  [xhr
   ajax-params]
  (let [response (get-response xhr)
        data (:data response)
        out (:out data)
        out (cstring/split
              out
              "\n")]
    (md/remove-element-content
      "#files-display")
    (md/remove-element-content
      "#display-file")
    (when-let [dir-name (:dir-name ajax-params)]
      (swap!
        current-directory
        form-absolute-path
        dir-name)
      (md/set-inner-html
        "#absolute-path"
        @current-directory))
    (doseq [line out]
      (let [doc-name (parse-doc-name
                       line)]
        (if (= (first line)
                 \d)
          (let [directory-link (a-fn
                                 doc-name
                                 {:onclick
                                   {:evt-fn list-file-system-fn
                                    :evt-p {:dir-name doc-name
                                            :success-fn prepare-file-system-fn-success2}}
                                  :oncontextmenu
                                   {:evt-fn remember-element-fn}})]
            (md/append-element
              "#files-display"
              directory-link))
          (let [file-link (a-fn
                            doc-name
                            {:onclick
                              {:evt-fn display-file-fn
                               :evt-p doc-name}
                             :oncontextmenu
                              {:evt-fn remember-element-fn}})]
            (md/append-element
              "#files-display"
              file-link))
         ))
     ))
 )

(defn prepare-file-system-fn-success
  "Query file system with \"ls -al\" command success"
  [xhr]
  (let [response (get-response xhr)
        data (:data response)
        out (:out data)
        [_
         home
         user-directory] (cstring/split
                           out
                           #"/")]
    (if (or (nil?
              home)
            (cstring/blank?
              home)
            (nil?
              user-directory))
      (reset!
        current-directory
        "/")
      (reset!
        current-directory
        (str
          "/"
          (cstring/trim
            home)
          "/"
          (cstring/trim
            user-directory))
       ))
    (md/set-inner-html
      "#absolute-path"
      @current-directory)
    (ajax
      {:url irurls/execute-shell-command-url
       :success-fn prepare-file-system-fn-success2
       :entity {:command (str
                           "ls -al "
                           (escape-space
                             @current-directory))}}
     ))
 )

(defn prepare-file-system-fn
  "Call server to return data about chosen document source"
  []
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn prepare-file-system-fn-success
     :entity {:command "echo $HOME"}}))

(defn mkdir-fn-success
  "Make directory success"
  [xhr
   ajax-params]
  (frm/close-popup)
  (let [dir-name (:dir-name ajax-params)]
    (ajax
      {:url irurls/execute-shell-command-url
       :success-fn prepare-file-system-fn-success2
       :entity {:command (str
                           "ls -al "
                           (escape-space
                             @current-directory)
                           "/"
                           (escape-space
                             dir-name))}
       :dir-name dir-name})
   ))

(defn mkdir-fn
  "Make directory request"
  []
  (let [new-folder-name (md/get-value
                          "#popup-input-id")]
    (ajax
      {:url irurls/execute-shell-command-url
       :success-fn mkdir-fn-success
       :entity {:command (str
                           "mkdir "
                           (escape-space
                             @current-directory)
                           "/"
                           (escape-space
                             new-folder-name))}
       :dir-name new-folder-name}))
 )

(defn custom-popup-content-fn
  "Custom popup form"
  [mkdir-evt]
  (div
    [(input
       ""
       {:id "popup-input-id"
        :type "text"})
     (input
       ""
       {:value (get-label
                 4)
        :type "button"}
       mkdir-evt)]))

(defn mkdir-popup-fn
  "Make directory popup for directory name"
  []
  (let [content (custom-popup-content-fn
                  {:onclick {:evt-fn mkdir-fn}})
        heading (get-label
                  1027)]
    (frm/popup-fn
      {:content content
       :heading heading}))
 )

(defn cut-fn
  "Cut document"
  []
  (reset!
    copy-value
    nil)
  (reset!
    cut-value
    (str
      @current-directory
      "/"
      @remembered-value))
 )

(defn copy-fn
  "Copy document"
  []
  (reset!
    cut-value
    nil)
  (reset!
    copy-value
    (str
      @current-directory
      "/"
      @remembered-value))
 )

(defn paste-fn-success
  "Paste document in file system success"
  []
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn prepare-file-system-fn-success2
     :entity {:command (str
                         "ls -al "
                         (escape-space
                           @current-directory))}}
   ))

(defn paste-fn
  "Paste document in file system request"
  []
  (when-let [cut-doc @cut-value]
    (reset!
      cut-value
      nil)
    (ajax
      {:url irurls/execute-shell-command-url
       :success-fn paste-fn-success
       :entity {:command (str
                           "mv "
                           (escape-space
                             cut-doc)
                           " "
                           (escape-space
                             @current-directory))}}
     ))
  (when-let [copy-doc @copy-value]
    (reset!
      copy-value
      nil)
    (ajax
      {:url irurls/execute-shell-command-url
       :success-fn paste-fn-success
       :entity {:command (str
                           "cp -r "
                           (escape-space
                             copy-doc)
                           " "
                           (escape-space
                             @current-directory))}}
     ))
 )

(defn delete-fn-success
  "Delete file from system success"
  []
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn prepare-file-system-fn-success2
     :entity {:command (str
                         "ls -al "
                         (escape-space
                           @current-directory))}}
   ))

(defn delete-fn
  "Delete file from system request"
  []
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn delete-fn-success
     :entity {:command (str
                         "rm -rf "
                         (escape-space
                           @current-directory)
                         "/"
                         (escape-space
                           @remembered-value))}}
   ))

(defn download-fn-success
  "Download file from system success"
  [xhr
   ajax-params]
  (let [operation (get-in
                    ajax-params
                    [:entity
                     :operation])]
    (when (= operation
             "download")
      (let [response (get-response
                       xhr)
            file-url (.createObjectURL
                       js/URL
                       response)
            download-link (gen
                            (a))]
        (aset
          download-link
          "href"
          file-url)
        (aset
          download-link
          "download"
          @remembered-value)
        (md/dispatch-event
          "click"
          download-link))
     ))
 )

(defn download-fn
  "Download file from system request"
  []
  (let [file-path (str
                    @current-directory
                    "/"
                    @remembered-value)]
    (ajax
      {:url irurls/read-file-url
       :success-fn download-fn-success
       :request-property-map {"responseType" "blob"
                              "cljResponseType" "blob"}
       :entity {:file-path file-path
                :operation "download"}}))
 )

(defn upload-fn-success
  "Download file from system success"
  [xhr
   ajax-params]
  (ajax
    {:url irurls/execute-shell-command-url
     :success-fn prepare-file-system-fn-success2
     :entity {:command (str
                         "ls -al "
                         (escape-space
                           @current-directory))}}
   )
  (frm/close-popup))

(def upload-file-a
     (atom nil))

(defn upload-fn
  "Upload file on system request"
  []
  (when @upload-file-a
    (let [file-input-el (md/query-selector
                          ".upload-fileds input[type='file']")
          upload-file-name (aget
                             (aget
                               (aget
                                 file-input-el
                                 "files")
                               0)
                             "name")
          file-path (str
                      @current-directory
                      "/"
                      upload-file-name)]
      (ajax
        {:url irurls/save-file-changes-url
         :success-fn upload-fn-success
         :entity {:file-path file-path
                  :file-content @upload-file-a
                  :is-base64 true}})
      (reset!
        upload-file-a
        nil))
   ))

(defn upload-popup
  "Displays modal dialog for file upload"
  []
  (let [upload-file-fn (fn []
                         (let [file-input-el (md/query-selector
                                               ".upload-fileds input[type='file']")
                               file (aget
                                      (aget
                                        file-input-el
                                        "files")
                                      0)
                               fileReader (js/FileReader.)
                               onload (aset
                                        fileReader
                                        "onload"
                                        ((fn []
                                           (fn [e]
                                             (reset!
                                               upload-file-a
                                               (aget
                                                 (aget
                                                   e
                                                   "target")
                                                 "result"))
                                            ))
                                         ))
                               dataURL (when file
                                         (.readAsDataURL
                                           fileReader
                                           file))]
                           
                          ))
        content (div
                  [(div
                     (input
                       nil
                       {:type "file"}
                       {:onchange {:evt-fn upload-file-fn}})
                     {:class "upload-fileds"})
                   (div
                     (input
                       nil
                       {:class "btn"
                        :value (get-label
                                 1079)
                        :type "button"}
                       {:onclick {:evt-fn upload-fn}})
                     {:class "upload-actions"})
                   ]
                  {:class "upload-container"})
        heading (get-label
                  1079)]
    (frm/popup-fn
      {:heading heading
       :content content}))
 )

(defn menu-fn
  "Custom context menu"
  [new-folder-evt
   cut-evt
   copy-evt
   delete-evt
   paste-evt
   download-evt
   upload-evt]
  (menu
    [(menuitem
       ""
       {:label (get-label
                 1027)}
       new-folder-evt)
     (menuitem
       ""
       {:label (get-label
                 1029)}
       cut-evt)
     (menuitem
       ""
       {:label (get-label
                 1030)}
       copy-evt)
     (menuitem
       ""
       {:label (get-label
                 8)}
       delete-evt)
     (menuitem
       ""
       {:label (get-label
                 1031)}
       paste-evt)
     (menuitem
       ""
       {:label (get-label
                 1078)}
       download-evt)
     (menuitem
       ""
       {:label (get-label
                 1079)}
       upload-evt)]
    {:type "context"
     :id "document-menu"}))

(defn file-system-area-html-fn
  "Generate shell HTML"
  [new-folder-evt
   cut-evt
   copy-evt
   delete-evt
   paste-evt
   download-evt
   upload-evt]
  (gen
    (div 
      [(div
         [(div
            ""
            {:id "absolute-path"})
          (div
            ""
            {:id "files-display"})
          (div
            ""
            {:id "display-file"})]
        {:class "display-content"})
       (menu-fn
         new-folder-evt
         cut-evt
         copy-evt
         delete-evt
         paste-evt
         download-evt
         upload-evt)]
      {:class "file-system-area"
       :contextmenu "document-menu"}))
 )

(defn display-file-system
  "Initial function for displaying file-system area"
  []
  (empty-then-append
    ".content"
    (file-system-area-html-fn
      {:onclick {:evt-fn mkdir-popup-fn}}
      {:onclick {:evt-fn cut-fn}}
      {:onclick {:evt-fn copy-fn}}
      {:onclick {:evt-fn delete-fn}}
      {:onclick {:evt-fn paste-fn}}
      {:onclick {:evt-fn download-fn}}
      {:onclick {:evt-fn upload-popup}}
     ))
  (prepare-file-system-fn))

